---
title: "Reliably Detected Genes in Sciatic Nerve Nanostring Data"
author: "Theo Killian"
date: "`r Sys.Date()`"
output:
  html_document:
    code_folding: hide
    toc: true
    toc_float: true
---

```{r, echo = FALSE, results = 'asis'}
suppressPackageStartupMessages(library("dplyr"))
knitr::opts_chunk$set(collapse=TRUE, comment="#>", warning=FALSE, message=FALSE)
```

# Introduction

We are trying to isolate a discrete list of reliably detected genes in sciatic
nerve (SN) Chat pos (Chat+) samples to report what transcripts are present in
these samples within a certain degree of confidence.

Ultimately, the method to determine reliability of detection that we used
previously is contingent on other samples used to calculate a Cook's Distance
to remove outliers, as well as base mean count and log fold change, we need to
develop a new way to ascertain what genes are present in SN Chat+ samples by
themselves.

We will attempt to accomplish an independent metric for reliable detection by
calculating the standard deviation (`SD`), mean gene counts (`mean_counts`),
filter out rows with all zeros and calculate z-score (`zscore`). The z-score
tells us "how far ahead, or how far below your raw score is from the mean,
in standard deviation units." Assuming a normal distribution, the standard
deviation and z-score are centered around zero.

In the following sections we will also normalize gene counts by sample area and
compare with the DESeq normalization. From there, we will filter on mean gene
counts to remove genes with low expression and measurements with high standard
deviation relative to the mean counts per gene.


```{r libraries}
library("dplyr")
library("tidyr")
library("tibble")
library("ggplot2")
library("readxl")
library("readr")
library("writexl")
library("matrixStats")
library("pheatmap")
library("naniar")
library("DT")
```

First, we load and display the sample metadata table containing the 4 sciatic
nerve (SN) Chat pos (Chat+) samples. We calculate the mean area for all such
samples and the ratio of the sample area divided by the mean (i.e. `area_mean`).

```{r}
## read nanostring metadata table
readxl::read_excel(path = paste0("./data/Metadata_SN_DP.xlsx")) %>%
  dplyr::filter(class == "CTRL", ## only control samples
                segment == "ChATpos" ## only Chat+ samples
                ) %>%
  dplyr::mutate(area = as.double(area), 
                area_mean = mean(area), ## mean area across rows
                area_ratio = area / area_mean) %>%## sample area / mean area
  dplyr::select(-c(expected_neg, scan_name)) %>%## remove extra columns
  as.data.frame() -> Metadata_SN_DP

# DT::datatable(Metadata_SN_DP)
```

Mean area of SN) Chat pos (Chat+) samples

```{r}
mean_area_chatpos <- unique(Metadata_SN_DP$area_mean)
mean_area_chatpos
```

Secondly, we displaying the list of all genes compared in the Chat+ and Chat- in
the previous SN DE comparison (whether they were significant or not). This list
is shown for comparison to what we will do later.

```{r}
readxl::read_excel(path = paste0("./data/SN_Chatpos_vs_Chatneg_DEG_outliers.xlsx"),
                   sheet = 1) %>%
  dplyr::select(genes:padj) %>%
  as.data.frame() -> sn_all
# DT::datatable(sn_all)
```

### List 1

Our previous method of determining reliable genes between Chat+ and Chat- in SN
consisted of filtering the full gene list for all genes not considered "low
count" (i.e. mean count > 8.33 DESeq normalized counts) and Cook's Distance less
than the Cook Cutoff (4 / 8 samples = 0.5 for this dataset). However, if we want
to merely find reliable genes for Chat+ SN samples alone, we cannot rely on
Cook's Distance, because that requires a linear model comparing DE genes with 
another group and that's not what we want to do. 

```{r}
readxl::read_excel(path = paste0("./data/SN_Chatpos_vs_Chatneg_DEG_outliers.xlsx"),
                   sheet = 1) %>%
  dplyr::filter(baseMean > 8.33,
                cooks_stat < 0.5) %>%
  dplyr::arrange(desc(baseMean)) %>%
  dplyr::select(genes:padj, Metadata_SN_DP$sample) %>%
  as.data.frame() -> sn_reliable1

DT::datatable(sn_reliable1)
```

Our "original reliable detected gene list" consisted of 1351 such genes:

```{r}
nrow(sn_reliable1)
```

### List 2

However, since we are only interested in reliable genes in Chat+ samples, so one
could consider only samples with a positive LFC within this list (meaning that
they are present or enriched in these samples).

```{r}
readxl::read_excel(path = paste0("./data/SN_Chatpos_vs_Chatneg_DEG_outliers.xlsx"),
                   sheet = 1) %>%
  dplyr::filter(baseMean > 8.33,
                cooks_stat < 0.5,
                log2FoldChange > 0) %>%
  dplyr::arrange(desc(baseMean)) %>%
  dplyr::select(genes:padj, Metadata_SN_DP$sample) %>%
  as.data.frame() -> sn_reliable2

DT::datatable(sn_reliable2)
```

This filtering yielded 482 "reliably detected" genes with positive LFC (i.e.
genes present or enriched in Chat+ samples) that also met the other criteria:

```{r}
nrow(sn_reliable2)
```

## Observing reliability metrics in gene lists

We should observe the distribution of outliers, and various statistical metrics
for our gene lists described above.

```{r}
readxl::read_excel(path = paste0("./data/SN_Chatpos_vs_Chatneg_DEG_outliers.xlsx"),
                   sheet = 1) %>%
  dplyr::filter(baseMean > 8.33,
                cooks_stat < 0.5) %>%
  dplyr::arrange(desc(baseMean)) %>%
  dplyr::select(genes, Metadata_SN_DP$sample) %>%
  dplyr::mutate(mean_counts = rowMeans(across(2:5))) %>%
  tidyr::gather(key = "sample", value = "counts", -c(genes, mean_counts)) %>%
  dplyr::group_by(genes) %>%
  dplyr::mutate(SD = sd(counts),
                zscore = (counts - mean(counts)) / sd(counts),
                max_zscore = max(zscore),
                CV = SD / mean_counts,
                sum_counts = sum(counts),
                gene_list = "list1") %>%
  tibble::rowid_to_column(var = "ID") %>%
  as.data.frame() -> sn_reliable_df1

readxl::read_excel(path = paste0("./data/SN_Chatpos_vs_Chatneg_DEG_outliers.xlsx"),
                   sheet = 1) %>%
  dplyr::filter(baseMean > 8.33,
                cooks_stat < 0.5,
                log2FoldChange > 0) %>%
  dplyr::arrange(desc(baseMean)) %>%
  dplyr::select(genes, Metadata_SN_DP$sample) %>%
  dplyr::mutate(mean_counts = rowMeans(across(2:5))) %>%
  tidyr::gather(key = "sample", value = "counts", -c(genes, mean_counts)) %>%
  dplyr::group_by(genes) %>%
  dplyr::mutate(SD = sd(counts),
                zscore = (counts - mean(counts)) / sd(counts),
                max_zscore = max(zscore),
                CV = SD / mean_counts,
                sum_counts = sum(counts),
                gene_list = "list2") %>%
  as.data.frame() -> sn_reliable_df2
```

```{r}
dplyr::bind_rows(sn_reliable_df1, sn_reliable_df2) %>%
  ggplot(aes(zscore, color = gene_list)) +
  geom_density() +
  ggtitle("Distribution of z-score in reliable gene lists")
```

I found this plot to be the most informative for visualizing variance. Here, we
plot teh coefficient of variance (CV) which is a ratio of standard deviation
(SD) divided by the mean counts. For example a CV of 1 means that there is at
least one sample with counts 100% above the mean counts, meaning that a given 
gene could have and average of 10 mean counts, but have one measurement at 5 or
15. Since there are a few genes with CVs as high as 1.5 in the reliable gene
lists, this seems unacceptably high, despite the fact that we removed most
outliers through the Cook's Cutoff filter. Diana and I decided that a CV cutoff
of 0.5 could serve as an arbitrary threshold to filter our samples while still
removing outliers.

```{r}
dplyr::bind_rows(sn_reliable_df1, sn_reliable_df2) %>%
  ggplot(aes(CV, color = gene_list)) +
  geom_density() +
  ggtitle("Distribution of CV in reliable gene lists")
```

```{r}
dplyr::bind_rows(sn_reliable_df1, sn_reliable_df2) %>%
  ggplot(aes(mean_counts, color = gene_list)) +
  geom_density() +
  ggtitle("Distribution of mean counts in reliable gene lists")
```

```{r}
dplyr::bind_rows(sn_reliable_df1, sn_reliable_df2) %>%
  ggplot(aes(SD, color = gene_list)) +
  geom_density() +
  ggtitle("Distribution of SD in reliable gene lists")
```

## Missingness analysis

We are going to pretend that the zero count values are `NA` to visualize zero
count values in an easier manner. It appears that we don't have many zero counts
in either reliable gene list, but there are a few (<1%)

```{r}
sn_reliable1 %>%
  dplyr::select(genes, Metadata_SN_DP$sample) -> sn_reliable1na
sn_reliable1na[sn_reliable1na == 0] <- NA
naniar::vis_miss(sn_reliable1na)
```

```{r}
sn_reliable2 %>%
  dplyr::select(genes, Metadata_SN_DP$sample) -> sn_reliable2na
sn_reliable2na[sn_reliable2na == 0] <- NA
naniar::vis_miss(sn_reliable2na)
```

## Z-score Heatmaps

```{r}
sn_reliable_df1 %>%
  dplyr::select(genes, sample, zscore) %>%
  tidyr::spread(key = "sample", value = "zscore") %>%
  tibble::column_to_rownames(var = "genes") %>%
  as.matrix() %>%
  pheatmap::pheatmap(show_rownames = FALSE)
```

```{r}
sn_reliable_df2 %>%
  dplyr::select(genes, sample, zscore) %>%
  tidyr::spread(key = "sample", value = "zscore") %>%
  tibble::column_to_rownames(var = "genes") %>%
  as.matrix() %>%
  pheatmap::pheatmap(show_rownames = FALSE)
```

## CV vs mean counts

```{r}
dplyr::bind_rows(sn_reliable_df1, sn_reliable_df2) %>%
  ggplot(aes(x = mean_counts, y = CV, color = gene_list)) +
  geom_point(size = 0.7, alpha = 0.7)
```

## SD vs mean counts

```{r}
dplyr::bind_rows(sn_reliable_df1, sn_reliable_df2) %>%
  ggplot(aes(x = mean_counts, y = SD, color = gene_list)) +
  geom_point(size = 0.7, alpha = 0.7)
```

## Sum counts

```{r}
dplyr::bind_rows(sn_reliable_df1, sn_reliable_df2) %>%
  ggplot(aes(sum_counts, color = gene_list)) +
  geom_density() +
  ggtitle("Distribution of mean counts in reliable gene lists")
```

## Normalization

To determine if the DESeq2 normalization is has worked, we will compare the
DESeq2 normalized counts with the raw counts normalized by area and observe the
results.

```{r}
readxl::read_excel(path = paste0("./data/Count_Matrix_Long_Whole_Dataset.xlsx")) %>%
  dplyr::filter(class == "CTRL", ## only control samples
                segment == "ChATpos", ## only Chat+ samples
                region == "SN") %>%## sciatic nerve
  dplyr::group_by(sample) %>%
  dplyr::mutate(area = as.double(area),
                area_mean = mean_area_chatpos, ## mean area across rows
                area_ratio = area / area_mean,
                area_norm_counts = cts/area_ratio) %>% ## counts / sample area / mean area
  dplyr::select(-c(expected_neg, scan_name)) %>% ## remove extra columns
  as.data.frame() -> raw_count_mat
```

<!-- ```{r} -->
<!--   # dplyr::mutate(mean_counts = rowMeans(across(1:4))) %>%-->
<!--   # dplyr::filter(mean_counts > 0) %>%## filter out rows with all zeros -->
<!--   # # tibble::rownames_to_column(var = "genes") %>%-->
<!--   # # tidyr::gather(key = "samples", value = "counts", -c(genes, SD, mean_counts)) %>%-->
<!--   # # dplyr::group_by(genes) %>%-->
<!--   # dplyr::mutate(zscore = (counts - mean(counts)) / sd(counts), -->
<!--   #               max_zscore = max(zscore), -->
<!--   #               CV = SD / mean_counts) %>%-->
<!-- ``` -->

<!-- ```{r} -->
<!-- ## read bulk normalized counts -->
<!-- readxl::read_excel(path = paste0("./data/SN_Chatpos_vs_Chatneg_DEG_outliers.xlsx"), -->
<!--                    sheet = 1) %>% -->
<!--   dplyr::select(genes, Metadata_SN_DP$sample) -> sn_chat_pos_DE_counts -->
<!-- # DT::datatable(sn_chat_pos_DE_counts) -->
<!-- ``` -->

<!-- The gene counts of each sample are divided by the area ratio, such that a sample -->
<!-- with more counts will be reduced and vice versa. -->

<!-- ```{r} -->
<!-- # sn_chat_pos_DE_counts %>%-->
<!-- #   dplyr::select(genes, Metadata_SN_DP$sample) %>%-->
<!-- #   dplyr::mutate( -->
<!-- #     Chat_pos_ctrl1 = DSP_1005580000422_D_A02.dcc / Metadata_SN_DP$area_ratio[1], -->
<!-- #     Chat_pos_ctrl2 = DSP_1005580000422_D_A10.dcc / Metadata_SN_DP$area_ratio[2], -->
<!-- #     Chat_pos_ctrl3 = DSP_1005580000422_D_B10.dcc / Metadata_SN_DP$area_ratio[3], -->
<!-- #     Chat_pos_ctrl4 = DSP_1005580000422_D_B12.dcc / Metadata_SN_DP$area_ratio[4]) %>% -->
<!-- #   dplyr::mutate(norm_mean_counts = rowMeans(across(2:5))) %>% -->
<!-- #   dplyr::mutate(non_norm_mean_counts = rowMeans(across(6:9))) %>% -->
<!-- #   as.data.frame() -> sn_chat_pos_norm_counts -->
<!-- # DT::datatable(sn_chat_pos_norm_counts) -->
<!-- ``` -->

We calculate the global mean counts before we normalize raw counts by area:

```{r}
## global mean count after area normalization
global_mean_raw <- mean(raw_count_mat$cts)
global_mean_raw
```

We calculate the global mean counts before after normalize raw counts by area:

```{r}
## global mean count after area normalization
global_mean_area_norm <- mean(raw_count_mat$area_norm_counts)
global_mean_area_norm
```

We calculate the global mean counts in DESeq normalized counts (which are
implicitly normalized by total sample counts, which is a proxy for sample area):

```{r}
readxl::read_excel(path = paste0("./data/SN_Chatpos_vs_Chatneg_DEG_outliers.xlsx"),
                   sheet = 1) %>%
  dplyr::select(Metadata_SN_DP$sample) %>%
  as.matrix() %>%
  mean() -> global_deseq_norm
global_deseq_norm
```

We observe that the area normalization of the raw counts does not change the
global mean count value that much (i.e. ~1%), but that global mean count of
DESeq counts is much higher (probably due to independent filtering) removing 
many low count genes, as well as variance-stabilizing normalization,
regressing gene counts towards the mean.

### Distribution of mean gene counts by normalization

Red dotted line is the raw mean count level across all genes.

```{r warning=FALSE}
readxl::read_excel(path = paste0("./data/SN_Chatpos_vs_Chatneg_DEG_outliers.xlsx"),
                   sheet = 1) %>%
  dplyr::select(genes, Metadata_SN_DP$sample) %>%
  tidyr::gather(key = "sample", value = "cts", -genes) %>%
  dplyr::group_by(genes) %>%
  dplyr::mutate(deseq_mean_counts = mean(cts)) %>%
  dplyr::arrange(desc(deseq_mean_counts)) %>%
  dplyr::filter(!duplicated(genes)) %>%
  dplyr::select(genes, deseq_mean_counts) -> sn_counts

## plot mean gene count distribution
raw_count_mat %>%
  dplyr::rename(genes = Genes) %>%
  dplyr::group_by(genes) %>%
  dplyr::mutate(raw_mean_counts = mean(cts),
                area_mean_counts = mean(area_norm_counts)) %>%
  dplyr::select(genes, raw_mean_counts, area_mean_counts) %>%
  dplyr::filter(!duplicated(genes)) %>%
  dplyr::arrange(desc(raw_mean_counts)) %>%
  dplyr::left_join(sn_counts, by = "genes") %>%
  tibble::rowid_to_column(var = "ID") %>%
  tidyr::gather(key = "normalization", value = "mean_counts", - c(genes, ID)) %>%
  ggplot(aes(x = ID, y = mean_counts, color = normalization)) +
  geom_line() +
  xlab("genes") +
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank()) +
  geom_hline(yintercept = global_mean_raw, color = "red", linetype = "dashed") +
  ggtitle("Distribution of mean gene counts in SN Chat+ control samples")
```

The following plot is a close up of the plot above, displaying only the top
100 genes. We observe that the normalization does not change the mean count per
gene very much.

```{r warning=FALSE}
## plot mean gene count distribution
raw_count_mat %>%
  dplyr::rename(genes = Genes) %>%
  dplyr::group_by(genes) %>%
  dplyr::mutate(raw_mean_counts = mean(cts),
                area_mean_counts = mean(area_norm_counts)) %>%
  dplyr::select(genes, raw_mean_counts, area_mean_counts) %>%
  dplyr::filter(!duplicated(genes)) %>%
  dplyr::arrange(desc(raw_mean_counts)) %>%
  dplyr::left_join(sn_counts, by = "genes") %>%
  tibble::rowid_to_column(var = "ID") %>%
  tidyr::gather(key = "normalization", value = "mean_counts", - c(genes, ID)) %>%
  ggplot(aes(x = ID, y = mean_counts, color = normalization)) +
  geom_line() +
  xlab("genes") +
  xlim(1, 100) +
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank()) +
  geom_hline(yintercept = global_mean_raw, color = "red", linetype = "dashed") +
  ggtitle("Distribution of mean gene counts in SN Chat+ control samples")
```

<!-- We load the gene counts for the 4 sciatic nerve (SN) Chat pos (Chat+) samples. -->
<!-- Note: that this is the list of all genes in the DE gene list (all genes whether -->
<!-- they are significant or not). We are just displaying the LFC and p-adjusted -->
<!-- values from the SN Chat+ vs Chat- values for reference to compare with previous -->
<!-- methods of filtering reliable genes. -->

<!-- ```{r} -->
<!-- ## plot mean gene count distribution -->
<!-- # raw_count_mat %>%-->
<!-- #   dplyr::rename(genes = Genes) %>%-->
<!-- #   dplyr::group_by(genes) %>%-->
<!-- #   dplyr::mutate(mean_counts = mean(cts), -->
<!-- #                 area_mean_counts = mean(area_norm_counts), -->
<!-- #                 zscore_raw = (cts - mean(cts)) / sd(cts), -->
<!-- #                 zscore_area_norm = (area_norm_counts - mean(cts)) / sd(area_norm_counts)) %>% -->
<!-- #   as.data.frame() -> a2 -->
<!--   # dplyr::select(genes, mean_counts, area_mean_counts) %>%-->
<!--   # tidyr::gather(key = "normalization", value = "mean_counts", -genes) %>%-->
<!--   # dplyr::arrange(desc(mean_counts)) %>%-->
<!--   # tibble::rowid_to_column(var = "ID") %>%-->

<!-- # sn_chat_pos_norm_counts %>%-->
<!-- #   dplyr::select(genes, contains("Chat")) %>%-->
<!-- #   tibble::column_to_rownames(var = "genes") -> sn_chat_pos_df -->
<!-- #  -->
<!-- # ## calculate the standard deviation for each row fo the normalized counts -->
<!-- # transform(sn_chat_pos_df, SD = rowSds(as.matrix(sn_chat_pos_df), na.rm = TRUE)) %>%-->
<!-- #   dplyr::mutate(mean_counts = rowMeans(across(1:4))) %>%-->
<!-- #   dplyr::filter(mean_counts > 0) %>%## filter out rows with all zeros -->
<!-- #   tibble::rownames_to_column(var = "genes") %>%-->
<!-- #   tidyr::gather(key = "samples", value = "counts", -c(genes, SD, mean_counts)) %>%-->
<!-- #   dplyr::group_by(genes) %>%-->
<!-- #   dplyr::mutate(zscore = (counts - mean(counts)) / sd(counts), -->
<!-- #                 max_zscore = max(zscore), -->
<!-- #                 CV = SD / mean_counts) %>%-->
<!-- #   as.data.frame() -> sn_chat_pos_norm_counts_sd -->
<!-- # DT::datatable(sn_chat_pos_norm_counts_sd) -->
<!-- ``` -->

<!-- ### Distribution of Z-score -->

<!-- Below displays the density distribution of z-score across all normalized gene -->
<!-- count measurements. Notice that we don't observe that this z-score distribution -->
<!-- does not approximate the normal distribution and not centered around zero, -->
<!-- meaning that there are bias in our data. -->

<!-- ```{r} -->
<!-- # sn_chat_pos_norm_counts_sd %>%-->
<!-- #   dplyr::arrange(desc(zscore)) %>%-->
<!-- #   tibble::rowid_to_column(var = "ID") %>%-->
<!-- #   ggplot(aes(zscore)) + -->
<!-- #   geom_density() + -->
<!-- #   ggtitle("Distribution of mean gene counts in SN Chat+ samples") -->
<!-- ``` -->

## Filtering

Based on the analysis above, we decided to introduce a cutoff of coefficient of
variance (CV) is less than 0.5 and mean count is greater than the global gene
mean count 3.22 in control Chat+ (i.e. `r global_mean_area_norm`). Given these
criteria, this leaves us with 5050 genes.

```{r }
raw_count_mat %>%
  dplyr::rename(genes = Genes) %>%
  dplyr::select(genes, sample, area_norm_counts) %>%
  tidyr::spread(key = "sample", value = "area_norm_counts") %>%
  tibble::column_to_rownames(var = "genes") %>%
  as.matrix() -> sn_chat_pos_area_norm

transform(sn_chat_pos_area_norm,
          SD = rowSds(as.matrix(sn_chat_pos_area_norm), na.rm = TRUE)) %>%
  dplyr::mutate(mean_counts = rowMeans(across(1:4))) %>%
  dplyr::filter(mean_counts > 0) %>%## filter out rows with all zeros
  tibble::rownames_to_column(var = "genes") %>%
  tidyr::gather(key = "samples", value = "counts", -c(genes, SD, mean_counts)) %>%
  dplyr::group_by(genes) %>%
  dplyr::mutate(zscore = (counts - mean(counts)) / sd(counts),
                max_zscore = max(zscore),
                sum_counts = sum(counts),
                CV = SD / mean_counts) %>%
  as.data.frame() -> sn_chat_pos_area_norm_counts_sd

sn_chat_pos_area_norm_counts_sd %>%
  dplyr::filter(!duplicated(genes),
                CV < 0.5,
                mean_counts > global_mean_area_norm
                # mean_counts > 8
                ) %>%
  as.data.frame() -> sn_chat_pos_area_norm_counts_pass_filter


# DT::datatable(sn_chat_pos_area_norm_counts_pass_filter)
```

Given these criteria, this leaves us with
`r nrow(sn_chat_pos_area_norm_counts_pass_filter)` genes.

We would like to do the same for FUS Chat+ samples as well, in the following
sections.

```{r}
## read nanostring metadata table
readxl::read_excel(path = paste0("./data/Metadata_SN_DP.xlsx")) %>%
  dplyr::filter(class == "FUS", ## only control samples
                segment == "ChATpos" ## only Chat+ samples
                ) %>%
  dplyr::mutate(area = as.double(area), 
                area_mean = mean(area), ## mean area across rows
                area_ratio = area / area_mean) %>%## sample area / mean area
  dplyr::select(-c(expected_neg, scan_name)) %>%## remove extra columns
  as.data.frame() -> Metadata_SN_DP_FUS

readxl::read_excel(path = paste0("./data/Count_Matrix_Long_Whole_Dataset.xlsx")) %>%
  dplyr::filter(class == "FUS", ## only control samples
                segment == "ChATpos", ## only Chat+ samples
                region == "SN") %>%## sciatic nerve
  dplyr::group_by(sample) %>%
  dplyr::mutate(area = as.double(area),
                area_mean = mean_area_chatpos, ## mean area across rows
                area_ratio = area / area_mean,
                area_norm_counts = cts/area_ratio) %>%## counts / sample area / mean area
  dplyr::select(-c(expected_neg, scan_name)) %>%## remove extra columns
  as.data.frame() -> raw_count_mat_FUS

global_mean_area_norm_FUS <- mean(raw_count_mat_FUS$area_norm_counts)
global_mean_area_norm_FUS
```

The global mean of area counts is pretty similar to control Chat+

```{r}
raw_count_mat_FUS %>%
  dplyr::rename(genes = Genes) %>%
  dplyr::group_by(genes) %>%
  dplyr::mutate(raw_mean_counts = mean(cts),
                area_mean_counts = mean(area_norm_counts)) %>%
  dplyr::select(genes, raw_mean_counts, area_mean_counts) %>%
  dplyr::filter(!duplicated(genes)) %>%
  dplyr::arrange(desc(raw_mean_counts)) %>%
  tibble::rowid_to_column(var = "ID") %>%
  tidyr::gather(key = "normalization", value = "mean_counts", - c(genes, ID)) %>%
  ggplot(aes(x = ID, y = mean_counts, color = normalization)) +
  geom_line() +
  xlab("genes") +
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank()) +
  geom_hline(yintercept = global_mean_area_norm_FUS, color = "red", linetype = "dashed") +
  ggtitle("Distribution of mean gene counts in SN Chat+ FUS samples")
```

We also observe that the area normalized counts do not change the distribution
of the raw FUS Chat+ counts very much, and that that majority of our data is
also low count.

```{r}
raw_count_mat_FUS %>%
  dplyr::rename(genes = Genes) %>%
  dplyr::select(genes, sample, area_norm_counts) %>%
  tidyr::spread(key = "sample", value = "area_norm_counts") %>%
  tibble::column_to_rownames(var = "genes") %>%
  as.matrix() -> sn_chat_pos_area_norm_FUS

transform(sn_chat_pos_area_norm_FUS,
          SD = rowSds(as.matrix(sn_chat_pos_area_norm_FUS), na.rm = TRUE)) %>%
  dplyr::mutate(mean_counts = rowMeans(across(1:4))) %>%
  dplyr::filter(mean_counts > 0) %>%## filter out rows with all zeros
  tibble::rownames_to_column(var = "genes") %>%
  tidyr::gather(key = "samples", value = "counts", -c(genes, SD, mean_counts)) %>%
  dplyr::group_by(genes) %>%
  dplyr::mutate(zscore = (counts - mean(counts)) / sd(counts),
                max_zscore = max(zscore),
                sum_counts = sum(counts),
                CV = SD / mean_counts) %>%
  as.data.frame() -> sn_chat_pos_area_norm_counts_sd_FUS

sn_chat_pos_area_norm_counts_sd_FUS %>%
  dplyr::filter(!duplicated(genes),
                CV < 0.5,
                mean_counts > global_mean_area_norm
                #mean_counts > 8
                ) %>%
  as.data.frame() -> sn_chat_pos_area_norm_counts_pass_filter_FUS
# nrow(sn_chat_pos_area_norm_counts_pass_filter_FUS)

# DT::datatable(sn_chat_pos_area_norm_counts_pass_filter_FUS)
```

However, when we filter using the same criteria (i.e. gene counts are greater
than global mean area in FUS Chat+ samples `r global_mean_area_norm_FUS`) as we
applied to the Chat+ control samples, we have even more genes:
`r nrow(sn_chat_pos_area_norm_counts_pass_filter_FUS)`

## Filtering 2

Alejandro seems to think that the best way to filter samples is sort genes by
gene count sums and then filter genes that have a minimum count under some
threshold (such as 3).

*Instead the list that I will be giving you will be the list of genes sorted by*
*greatest sum of gene counts across samples, while filtering out genes that have*
*minimum counts at thresholds 3, 6 and 8 for both control Chat+ and Fus Chat+*
*You can decide additional cutoffs of these genes based on SD, CV, or other criteria*

```{r}
sn_chat_pos_area_norm_counts_sd %>%
  dplyr::group_by(genes) %>% 
  dplyr::mutate(min_counts = min(counts)) %>%
  dplyr::filter(min_counts > 3) %>% 
  dplyr::arrange(desc(sum_counts)) -> sn_chat_pos_area_norm_counts_sd_3

sn_chat_pos_area_norm_counts_sd %>%
  dplyr::group_by(genes) %>% 
  dplyr::mutate(min_counts = min(counts)) %>%
  dplyr::filter(min_counts > 6) %>% 
  dplyr::arrange(desc(sum_counts)) -> sn_chat_pos_area_norm_counts_sd_6

sn_chat_pos_area_norm_counts_sd %>%
  dplyr::group_by(genes) %>% 
  dplyr::mutate(min_counts = min(counts)) %>%
  dplyr::filter(min_counts > 8) %>% 
  dplyr::arrange(desc(sum_counts)) -> sn_chat_pos_area_norm_counts_sd_8

sn_chat_pos_area_norm_counts_sd_3 %>%
  dplyr::select(genes, samples, counts) %>%
  tidyr::spread(key = "samples", value = "counts") -> ctrl_3_wide

sn_chat_pos_area_norm_counts_sd_6 %>%
  dplyr::select(genes, samples, counts) %>%
  tidyr::spread(key = "samples", value = "counts") -> ctrl_6_wide

sn_chat_pos_area_norm_counts_sd_8 %>%
  dplyr::select(genes, samples, counts) %>%
  tidyr::spread(key = "samples", value = "counts") -> ctrl_8_wide
```

The three thresholds leave us with the following numbers of genes for Control

```{r}
nrow(sn_chat_pos_area_norm_counts_sd_3) ## 3
```

```{r}
nrow(sn_chat_pos_area_norm_counts_sd_6) ## 6
```

```{r}
nrow(sn_chat_pos_area_norm_counts_sd_8) ## 8
```

```{r}
sn_chat_pos_area_norm_counts_sd_FUS %>%
  dplyr::group_by(genes) %>% 
  dplyr::mutate(min_counts = min(counts)) %>%
  dplyr::filter(min_counts > 3) %>% 
  dplyr::arrange(desc(sum_counts)) -> sn_chat_pos_area_norm_counts_sd_FUS_3

sn_chat_pos_area_norm_counts_sd_FUS %>%
  dplyr::group_by(genes) %>% 
  dplyr::mutate(min_counts = min(counts)) %>%
  dplyr::filter(min_counts > 6) %>% 
  dplyr::arrange(desc(sum_counts)) -> sn_chat_pos_area_norm_counts_sd_FUS_6

sn_chat_pos_area_norm_counts_sd_FUS %>%
  dplyr::group_by(genes) %>% 
  dplyr::mutate(min_counts = min(counts)) %>%
  dplyr::filter(min_counts > 8) %>% 
  dplyr::arrange(desc(sum_counts)) -> sn_chat_pos_area_norm_counts_sd_FUS_8

sn_chat_pos_area_norm_counts_sd_FUS_3 %>%
  dplyr::select(genes, samples, counts) %>%
  tidyr::spread(key = "samples", value = "counts") -> FUS_3_wide

sn_chat_pos_area_norm_counts_sd_FUS_6 %>%
  dplyr::select(genes, samples, counts) %>%
  tidyr::spread(key = "samples", value = "counts") -> FUS_6_wide

sn_chat_pos_area_norm_counts_sd_FUS_8 %>%
  dplyr::select(genes, samples, counts) %>%
  tidyr::spread(key = "samples", value = "counts") -> FUS_8_wide
```

The three thresholds leave us with the following numbers of genes for FUS

```{r}
nrow(sn_chat_pos_area_norm_counts_sd_FUS_3) ## 3
```

```{r}
nrow(sn_chat_pos_area_norm_counts_sd_FUS_6) ## 6
```

```{r}
nrow(sn_chat_pos_area_norm_counts_sd_FUS_8) ## 8
```

## Save Data

```{r }
new_reliable2 <- list(sn_chat_pos_area_norm_counts_sd_FUS_3,
                     sn_chat_pos_area_norm_counts_sd_FUS_6,
                     sn_chat_pos_area_norm_counts_sd_FUS_8,
                     FUS_3_wide, FUS_6_wide, FUS_8_wide)
names(new_reliable2) <- c("Chatpos FUS genes min ct3",
                         "Chatpos FUS genes min ct3 stats",
                         "Chatpos FUS genes min ct6",
                         "Chatpos FUS genes min ct6 stats",
                         "Chatpos FUS genes min ct8",
                         "Chatpos FUS genes min ct8 stats")

writexl::write_xlsx(x = new_reliable2,
                    path = paste0(
                      "./data/SN_Nanostring_FUS_Chatpos_reliably_detected_by_count.xlsx"))

new_reliable3 <- list(sn_chat_pos_area_norm_counts_sd_3,
                     sn_chat_pos_area_norm_counts_sd_6,
                     sn_chat_pos_area_norm_counts_sd_8,
                     ctrl_3_wide, ctrl_6_wide, ctrl_8_wide)
names(new_reliable3) <- c("Chatpos FUS genes min ct3",
                         "Chatpos FUS genes min ct3 stats",
                         "Chatpos FUS genes min ct6",
                         "Chatpos FUS genes min ct6 stats",
                         "Chatpos FUS genes min ct8",
                         "Chatpos FUS genes min ct8 stats")

writexl::write_xlsx(x = new_reliable3,
                    path = paste0(
                      "./data/SN_Nanostring_Control_chatpos_reliably_detected_by_count.xlsx"))


sn_chat_pos_area_norm_counts_sd %>%
  dplyr::filter(genes %in% sn_chat_pos_area_norm_counts_pass_filter$genes
                ) -> ctrl_long


sn_chat_pos_area_norm_counts_sd_FUS %>%
  dplyr::filter(genes %in% sn_chat_pos_area_norm_counts_pass_filter_FUS$genes
                ) -> FUS_long

sn_chat_pos_area_norm_counts_sd %>%
  dplyr::select(genes, samples, counts) %>%
  tidyr::spread(key = "samples", value = "counts") -> ctrl_wide

sn_chat_pos_area_norm_counts_sd_FUS %>%
  dplyr::select(genes, samples, counts) %>%
  tidyr::spread(key = "samples", value = "counts") -> FUS_wide

sn_chat_pos_area_norm_counts_sd %>% 
  dplyr::select(genes, SD, mean_counts, max_zscore, sum_counts, CV) %>% 
  dplyr::filter(!duplicated(genes)) -> ctrl_long2
names(ctrl_long2) <- c("genes", paste0(names(ctrl_long2)[2:6], "_control"))

sn_chat_pos_area_norm_counts_sd_FUS %>%
  dplyr::select(genes, SD, mean_counts, max_zscore, sum_counts, CV) %>% 
  dplyr::filter(!duplicated(genes)) -> FUS_long2
names(FUS_long2) <- c("genes", paste0(names(FUS_long2)[2:6], "_FUS"))

ctrl_wide %>% 
  dplyr::full_join(ctrl_long2, by = c("genes")) %>% 
  dplyr::full_join(FUS_long2, by = c("genes")) %>% 
  dplyr::full_join(FUS_wide, by = c("genes")) %>% 
  dplyr::arrange(desc(sum_counts_control)) -> master_table

new_reliable1 <- list(master_table, ctrl_wide, ctrl_long, FUS_wide, FUS_long)
names(new_reliable1) <- c("control and FUS master table",
                          "Chatpos ctrl new gene counts",
                          "Chatpos ctrl new gene stats",
                          "Chatpos FUS new gene counts",
                          "Chatpos FUS new gene stats")

writexl::write_xlsx(x = new_reliable1,
                    path = paste0(
                      "./data/SN_Nanostring_new_reliably_detected_by_CV.xlsx"))
```

<!-- ```{r} -->
<!-- # sessioninfo::session_info() -->
<!-- ``` -->
