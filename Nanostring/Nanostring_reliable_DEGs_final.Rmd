---
title: "Nanostring Differential Expression Comparisons"
author: "Theo Killian"
date: "`r Sys.Date()`"
output:
  html_document:
    code_folding: hide
    toc: true
    toc_float: true
---

```{r, echo = FALSE, results = 'asis'}
suppressPackageStartupMessages(library("dplyr"))
knitr::opts_chunk$set(collapse=TRUE, comment="#>", warning=FALSE, message=FALSE)
```

# Introduction

This report describes the steps taken to analyze DSP GeoMx Nanostring whole
mouse genome probe count data via differential expression (DE) analysis using
the R Bioconductor tool, [DESeq2](https://bioconductor.org/packages/devel/bioc/vignettes/DESeq2/inst/doc/DESeq2.html).
This report details the various differentially expressed genes (DEGs) that have
been observed between various experimental conditions. 

```{r load_libraries, warning=FALSE, message=FALSE}
library("dplyr")
library("tidyr")
library("tibble")
library("readr")
library("readxl")
library("writexl")
library("ggplot2")
library("ggrepel")
library("DESeq2")
library("pheatmap")
library("naniar")
library("DT")
```

## Load Data

The original data we are analyzing is the "long form" non-normalized count
matrix previously generated by Maria using the raw Nanostring probe data file.

### Count Matrix

This file "long form" Nanostring file is loaded and converted to "wide" form
count matrix that can be analyzed by *DESeq2*, as described in the [DESeq2 vignette](https://bioconductor.org/packages/devel/bioc/vignettes/DESeq2/inst/doc/DESeq2.html).

```{r load_count, warning=FALSE, message=FALSE}
## read long format count file
readxl::read_excel(path = paste0(
  "../202307_piol/data/Maria_Count_Matrices/Raw/Whole_Dataset/",
  "Count_Matrix_Long_Whole_Dataset.xlsx")) %>% 
  as.data.frame() -> raw_df

## convert long format dataframe to wide count matrix
raw_df %>% 
  dplyr::select(Genes, sample, cts) %>% 
  tidyr::pivot_wider(names_from = "Genes", values_from = "cts") %>%
  tibble::column_to_rownames(var = "sample") %>%
  t() %>% as.data.frame() -> count_mat
```

### Metadata Table

In addition to the count matrix, *DESeq2* also requires a metadata table (i.e.
ColData/Column Data) that has row names which match the columns of the the
count matrix. This table is constructed below. Note: this table contains all 16
samples.

```{r load_metadata, warning=FALSE, message=FALSE}
## create metadata table (colData) from long data 
raw_df %>% 
  dplyr::filter(!duplicated(sample)) %>%
  dplyr::select(-c(Genes, cts, expected_neg, scan_name)) %>%
  dplyr::mutate(group = paste0(region, "_", segment),
                condition = paste0(class, "_", segment)) %>%
  # dplyr::filter(region == "SN",   ## only sciatic nerve samples are selected
  #               class != "TDP_43" ## no TDP-43 samples are selected!
  #               ) %>%
  dplyr::arrange(segment) %>%
  dplyr::mutate_all(as.factor) %>%
  as.data.frame() -> meta
rownames(meta) <- meta$sample
DT::datatable(as.tibble(meta))
```

## DE Comparisons

DE analysis is performed pairwise between conditions within the count matrix.
For more information, please consult the [DESeq2 vignette](https://bioconductor.org/packages/devel/bioc/vignettes/DESeq2/inst/doc/DESeq2.html#why-un-normalized-counts).

### DE Chat-positive vs Chat-negative in control sciatic nerve

DE is performed between samples in the `CTRL_ChATpos` and `CTRL_ChATneg`
conditions and the resulting DEGs are *sorted by significant p-value*

```{r de1, warning=FALSE, message=FALSE}
## run DESeq2
dds <- DESeqDataSetFromMatrix(countData = count_mat %>%
                                dplyr::select(meta$sample) %>%
                                as.matrix(),
                              colData = meta,
                              design = ~ condition)
keep <- rowSums(counts(dds)) > 0
dds <- DESeq(dds[keep, ])
res1 <- results(object = dds,
                contrast = c("condition", "CTRL_ChATpos", "CTRL_ChATneg"),
                alpha = 0.05)

## this code chunk extracts the Cook's Distance
as.data.frame(mcols(dds)$maxCooks) %>%
  dplyr::rename(cooks_stat = names(.)[1]) %>%
  dplyr::arrange(desc(cooks_stat)) %>%
  tibble::rownames_to_column(var = "genes") -> top_cooks1

merge(as.data.frame(res1), as.data.frame(counts(dds, normalized = TRUE)),
      by = "row.names", sort = FALSE) %>%
  as.data.frame() %>%
  dplyr::arrange(pvalue) %>%
  dplyr::rename(genes = names(.)[1]) %>%
  dplyr::left_join(top_cooks1, by = "genes") %>%
  dplyr::select(genes, cooks_stat, everything()) -> rd1
```

```{r de1_table, warning=FALSE, message=FALSE}
DT::datatable(rd1)
```

#### Number of significant DEGs

This describes how many differentially expressed genes (DEGs) with significant
p-values that also have a Cook's Distance that is less than the Cook's Cutoff
(i.e. they are not outliers).

```{r}
rd1 %>%
  dplyr::filter(pvalue < 0.05,
                cooks_stat < 4/nrow(meta)) -> sig1
nrow(sig1)
```

#### Heatmap of top 20 filtered significant DEGs

```{r heat1, warning=FALSE, message=FALSE}
## log transform top 20 genes
sig1 %>%
  dplyr::slice(1:20) %>%
  dplyr::select(genes, meta %>%
                  dplyr::filter(grepl("CTRL", condition)) %>%
                  dplyr::arrange(class) %>%
                  dplyr::select(sample) %>%
                  dplyr::pull()) %>%
  tibble::column_to_rownames(var = "genes") %>%
  dplyr::mutate_all(log10) %>%
  as.matrix() -> sig_log1
is.na(sig_log1) <- sapply(sig_log1, is.infinite)
sig_log1[is.na(sig_log1)] <- 0

## annotation column
data.frame(sample = meta %>%
                  dplyr::filter(grepl("CTRL", condition)) %>%
                  dplyr::arrange(class) %>%
                  dplyr::select(sample) %>%
                  dplyr::pull(),
           condition = meta %>%
                  dplyr::filter(grepl("CTRL", condition)) %>%
                  dplyr::arrange(class) %>%
                  dplyr::select(condition) %>%
                  dplyr::pull()) %>%
  tibble::column_to_rownames(var = "sample") -> sample_col

## heatmap
sig_log1 %>%
  pheatmap::pheatmap(#show_rownames = FALSE,
                     cluster_rows = FALSE,
                     cluster_cols = FALSE,
                     annotation_col = sample_col,
                     main = "CTRL_ChATpos vs CTRL_ChATneg")
```

#### DEG Volcano plot

Note: this is just a volcano displaying all genes. "Significance" is considered
to be *pvalue less than 0.05 and the absolute value of LFC is greater than 1.*

```{r vol1, warning=FALSE, message=FALSE}
# pdf(file = paste0("./plots/SN_chatpos_vs_chatneg_ctrl_reliable_gene_volcano.pdf"))
rd1 %>%
  dplyr::filter(!is.na(pvalue)) %>%
  dplyr::mutate(threshold = as.factor(abs(log2FoldChange) > 1 & pvalue < 0.05),
                group = as.factor(dplyr::case_when(
                  log2FoldChange > 1 & pvalue < 0.05 ~ "ChATpos",
                  log2FoldChange < -1 & pvalue < 0.05 ~ "ChATneg",
                  TRUE ~ "not significant"))) %>%
  ggplot(aes(x = log2FoldChange, y = -log10(pvalue), color = group)) +
  geom_point(alpha = 0.75, size = 0.75) +
  geom_hline(yintercept = -log10(0.05), color = "red", linetype = "dashed") +
  geom_vline(xintercept = -1, color = "red", linetype = "dashed") +
  geom_vline(xintercept = 1, color = "red", linetype = "dashed") +
  xlab("log2 fold change") +
  ylab("-log10 p-value") +
  theme(plot.title = element_text(hjust = 0.5)) +
  scale_color_manual(values = c("magenta", "limegreen", "gray3"))
# dev.off()
```

### DE Control vs FUS in Chat-positive sciatic nerve

DE is performed between samples in the `CTRL_ChATpos` and `FUS_ChATpos`
conditions and the resulting DEGs are *sorted by significant p-value*

```{r de2, warning=FALSE, message=FALSE}
## run DESeq2
dds <- DESeqDataSetFromMatrix(countData = count_mat %>%
                                dplyr::select(meta$sample) %>%
                                as.matrix(),
                              colData = meta,
                              design = ~ condition)
keep <- rowSums(counts(dds)) > 0
dds <- DESeq(dds[keep, ])
res2 <- results(object = dds,
                contrast = c("condition", "CTRL_ChATpos", "FUS_ChATpos"),
                alpha = 0.05)

as.data.frame(mcols(dds)$maxCooks) %>%
  dplyr::rename(cooks_stat = names(.)[1]) %>%
  dplyr::arrange(desc(cooks_stat)) %>%
  tibble::rownames_to_column(var = "genes") -> top_cooks2

merge(as.data.frame(res2), as.data.frame(counts(dds, normalized = TRUE)),
      by = "row.names", sort = FALSE) %>%
  as.data.frame() %>%
  dplyr::arrange(pvalue) %>%
  dplyr::rename(genes = names(.)[1]) %>%
  dplyr::left_join(top_cooks2, by = "genes") %>%
  dplyr::select(genes, cooks_stat, everything()) -> rd2
```

```{r de2_table, warning=FALSE, message=FALSE}
DT::datatable(rd2)
```

#### Number of significant DEGs

This describes how many differentially expressed genes (DEGs) with significant
p-values that also have a Cook's Distance that is less than the Cook's Cutoff
(i.e. they are not outliers).

```{r}
rd2 %>%
  dplyr::filter(pvalue < 0.05,
                cooks_stat < 4/nrow(meta)) -> sig2
nrow(sig2)
```

#### Heatmap of top 20 filtered significant DEGs

```{r heat2, warning=FALSE, message=FALSE}
## log transform top 20 genes
sig2 %>%
  dplyr::slice(1:20) %>%
  dplyr::select(genes, meta %>%
                  dplyr::filter(grepl("ChATpos", condition)) %>%
                  dplyr::arrange(class) %>%
                  dplyr::select(sample) %>%
                  dplyr::pull()) %>%
  tibble::column_to_rownames(var = "genes") %>%
  dplyr::mutate_all(log10) %>%
  as.matrix() -> sig_log2
is.na(sig_log2) <- sapply(sig_log2, is.infinite)
sig_log2[is.na(sig_log2)] <- 0

## annotation column
data.frame(sample = meta %>%
                  dplyr::filter(grepl("ChATpos", condition)) %>%
                  dplyr::arrange(class) %>%
                  dplyr::select(sample) %>%
                  dplyr::pull(),
           condition = meta %>%
                  dplyr::filter(grepl("ChATpos", condition)) %>%
                  dplyr::arrange(class) %>%
                  dplyr::select(condition) %>%
                  dplyr::pull()) %>%
  tibble::column_to_rownames(var = "sample") -> sample_col

## heatmap
sig_log2 %>%
  pheatmap::pheatmap(#show_rownames = FALSE,
                     cluster_rows = FALSE,
                     cluster_cols = FALSE,
                     annotation_col = sample_col,
                     main = "CTRL_ChATpos vs FUS_ChATpos")
```

#### DEG Volcano plot

Note: this is just a volcano displaying all genes. "Significance" is considered
to be *pvalue less than 0.05 and the absolute value of LFC is greater than 1.*

```{r vol2, warning=FALSE, message=FALSE}
# pdf(file = paste0("./data/SN_CTRL_vs_FUS_in_chatpos_reliable_gene_volcano.pdf"))
rd2 %>%
  dplyr::filter(!is.na(pvalue)) %>%
  dplyr::mutate(threshold = as.factor(abs(log2FoldChange) > 1 & pvalue < 0.05),
                group = as.factor(dplyr::case_when(
                  log2FoldChange > 1 & pvalue < 0.05 ~ "CTRL",
                  log2FoldChange < -1 & pvalue < 0.05 ~ "FUS",
                  TRUE ~ "not significant"))) %>%
  ggplot(aes(x = log2FoldChange, y = -log10(pvalue), color = group)) +
  geom_point(alpha = 0.75, size = 0.75) +
  geom_hline(yintercept = -log10(0.05), color = "red", linetype = "dashed") +
  geom_vline(xintercept = -1, color = "red", linetype = "dashed") +
  geom_vline(xintercept = 1, color = "red", linetype = "dashed") +
  xlab("log2 fold change") +
  ylab("-log10 p-value") +
  theme(plot.title = element_text(hjust = 0.5)) +
  scale_color_manual(values = c("magenta", "limegreen", "gray3"))
# dev.off()
```

### DE control vs FUS (full model)

DE is performed between samples in the `ChATpos` and `ChATpos` samples, using a
full linear model that accounts for `class` and `segment` conditions and the
resulting DEGs are *sorted by significant p-value*.

```{r de3, warning=FALSE, message=FALSE}
## run DESeq2
dds <- DESeqDataSetFromMatrix(countData = count_mat %>%
                                dplyr::select(meta$sample) %>%
                                as.matrix(),
                              colData = meta,
                              design = ~ class + segment)
keep <- rowSums(counts(dds)) > 0
dds <- DESeq(dds[keep, ])
res3 <- results(object = dds,
                contrast = c("class", "CTRL", "FUS"),
                alpha = 0.05)

as.data.frame(mcols(dds)$maxCooks) %>%
  dplyr::rename(cooks_stat = names(.)[1]) %>%
  dplyr::arrange(desc(cooks_stat)) %>%
  tibble::rownames_to_column(var = "genes") -> top_cooks3

merge(as.data.frame(res3), as.data.frame(counts(dds, normalized = TRUE)),
      by = "row.names", sort = FALSE) %>%
  as.data.frame() %>%
  dplyr::arrange(pvalue) %>%
  dplyr::rename(genes = names(.)[1]) %>%
  dplyr::left_join(top_cooks3, by = "genes") %>%
  dplyr::select(genes, cooks_stat, everything()) -> rd3
```

```{r de3_table, warning=FALSE, message=FALSE}
DT::datatable(rd3)
```

#### Number of significant DEGs

This describes how many differentially expressed genes (DEGs) with significant 
p-values that also have a Cook's Distance that is less than the Cook's Cutoff
(i.e. they are not outliers).

```{r}
rd3 %>%
  dplyr::filter(pvalue < 0.05,
                cooks_stat < 4/nrow(meta)) -> sig3
nrow(sig3)
```

#### Heatmap of top 20 filtered significant DEGs

```{r heat3, warning=FALSE, message=FALSE}
## log transform top 20 genes
sig3 %>%
  dplyr::slice(1:20) %>%
  dplyr::select(genes, contains("DSP")) %>%
  tibble::column_to_rownames(var = "genes") %>% 
  dplyr::mutate_all(log10) %>%
  as.matrix() -> sig_log3
is.na(sig_log3) <- sapply(sig_log3, is.infinite)
sig_log3[is.na(sig_log3)] <- 0

## annotation column
data.frame(sample = meta %>%
                  dplyr::arrange(class) %>%
                  dplyr::select(sample) %>%
                  dplyr::pull(),
           segment = meta %>%
                  dplyr::arrange(class) %>%
                  dplyr::select(segment) %>%
                  dplyr::pull(),
           class = meta %>%
                  dplyr::arrange(class) %>%
                  dplyr::select(class) %>%
                  dplyr::pull()) %>%
  tibble::column_to_rownames(var = "sample") -> sample_col3

## heatmap
sig_log3 %>%
  as.data.frame() %>% 
  dplyr::select(rownames(sample_col3)) %>% 
  as.matrix() %>%
  pheatmap::pheatmap(cluster_rows = FALSE,
                     cluster_cols = FALSE,
                     annotation_col = sample_col3,
                     main = "Control vs FUS all samples")
```

#### DEG Volcano plot

Note: this is just a volcano displaying all genes. "Significance" is considered
to be *pvalue less than 0.05 and the absolute value of LFC is greater than 1.*

```{r vol3, warning=FALSE, message=FALSE}
# pdf(file = paste0("./data/SN_CTRL_vs_FUS_in_chatpos_reliable_gene_volcano.pdf"))
rd3 %>%
  dplyr::filter(!is.na(pvalue)) %>%
  dplyr::mutate(threshold = as.factor(abs(log2FoldChange) > 1 & pvalue < 0.05),
                group = as.factor(dplyr::case_when(
                  log2FoldChange > 1 & pvalue < 0.05 ~ "Chat+",
                  log2FoldChange < -1 & pvalue < 0.05 ~ "Chat-",
                  TRUE ~ "not significant"))) %>%
  ggplot(aes(x = log2FoldChange, y = -log10(pvalue), color = group)) +
  geom_point(alpha = 0.75, size = 0.75) +
  geom_hline(yintercept = -log10(0.05), color = "red", linetype = "dashed") +
  geom_vline(xintercept = -1, color = "red", linetype = "dashed") +
  geom_vline(xintercept = 1, color = "red", linetype = "dashed") +
  xlab("log2 fold change") +
  ylab("-log10 p-value") +
  theme(plot.title = element_text(hjust = 0.5)) +
  scale_color_manual(values = c("magenta", "limegreen", "gray3"))
# dev.off()
```

## QC Plots

The following sections display several plots to check assumptions about our DE
model.

### PCA

Principal components analysis (PCA) is a method of visually identifying the
similarity or difference between samples. PCA rotates the data cloud onto an
orthogonal basis determined by the dimensions of maximal variance. The first two
Principal Components (PCs) usually hold the majority of the variance of the
data. The following plot shows the count matrix samples projected onto the two
largest Principal Components (PC1 and PC2). 

```{r PCA_transformation, warning=FALSE, message=FALSE}
## perform regularized log transformation and PCA and plot with ggplot2
rld <- DESeq2::rlogTransformation(dds)
# rld <- DESeq2::vst(dds)

plotPCA(rld, intgroup = "condition") +
  theme(plot.title = element_text(hjust = 0.5)) +
  geom_text_repel(aes(label = colnames(rld)),
                  arrow = arrow(length = unit(0.03, "npc"),
                  type = "closed", ends = "first"), force = 5) +
  ggtitle("PCA displaying experimental conditions")
```

### Size Factors

The box plot below illustrates the distribution of size factors across the 
samples being compared in this analysis and provides a general idea of the total
number of counts found in each sample. `Chatneg` samples are shown in blue,
while `Chatpos` samples are shown in rose. Note: we observe a lower number of
total counts in the  `Chatpos` samples. The average size factor level is shown
in red.

```{r sizefactors, warning=FALSE, message=FALSE}
dds$sizeFactor %>% 
  as.data.frame() %>%
  dplyr::rename(size_factors = names(.)[1]) %>%
  tibble::rownames_to_column(var = "sample") %>% 
  dplyr::left_join(meta, by = "sample") %>%
  dplyr::arrange(desc(segment)) %>%
  ggplot(aes(x = sample, y = size_factors, fill = segment)) +
  geom_bar(stat = "identity") +
  geom_hline(yintercept = mean(dds$sizeFactor), color = "red",
             linetype = "dashed") +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)) +
  ggtitle("Size Factors by sample")
```

## Reliably detected genes

Below, we will generate a list of reliably detected genes *across* all
conditions, arranged by genes with the *highest average counts*.

* `total_mean_counts` = total mean counts of each gene across all samples
* `total_counts` = total counts of each gene across all samples
* `mean_counts_CTRL_ChATneg` = total mean counts of each gene across `CTRL_ChATneg` samples
* `mean_counts_FUS_ChATneg` = total mean counts of each gene across `FUS_ChATneg` samples
* `mean_counts_CTRL_ChATpos` = total mean counts of each gene across `CTRL_ChATpos` samples
* `mean_counts_FUS_ChATpos` = total mean counts of each gene across `FUS_ChATpos` samples
* `zero_cts` = total number of samples with zero gene counts across all samples
* `cooks_stat` = Cook's Distance based on the *DESeq2* model

Note: In this case, the Cook's Cutoff = 4 / number of samples = 0.25, therefore
any gene with `cooks_stat` (i.e. Cook's Distance) > 0.25 is an outlier.

```{r reliable_genes, warning=FALSE, message=FALSE}
norm_cts <- as.data.frame(counts(dds, normalized = TRUE))
norm_cts$non_zero_vals <- apply(norm_cts == 0, 1, function(x) sum(x == 0))
norm_cts %>%
  dplyr::select(meta %>%
                  dplyr::arrange(class) %>%
                  dplyr::select(sample) %>%
                  dplyr::pull(),
                non_zero_vals) %>%
  dplyr::mutate(total_mean_counts = rowMeans(across(1:16)),
                total_counts = rowSums(across(1:16)),
                mean_counts_CTRL_ChATneg = rowMeans(across(1:4)),
                mean_counts_FUS_ChATneg = rowMeans(across(5:8)),
                mean_counts_CTRL_ChATpos = rowMeans(across(9:12)),
                mean_counts_FUS_ChATpos = rowMeans(across(13:16)),
                zero_cts = (non_zero_vals - 16) * -1) %>%
  tibble::rownames_to_column(var = "genes") %>%
  dplyr::left_join(top_cooks1, by = "genes") %>%
  dplyr::select(genes, cooks_stat, zero_cts, total_counts,
                contains("mean_counts"), everything()) %>%
  dplyr::select(-non_zero_vals) %>%
  dplyr::arrange(desc(total_counts)) %>%
  as.data.frame() -> norm_gene_stats
DT::datatable(norm_gene_stats)
```

### Distribution of total mean counts

The following plot displays the distribution of average counts per gene across
all samples (counts above 50 are not shown).

* Global mean expression of `r {mean(norm_gene_stats$total_mean_counts)}` counts shown in red
* Mean expression of Eif5a `r {rd1 %>% dplyr::filter(genes == "Eif5a") %>% dplyr::select(baseMean) %>% pull()}` counts shown in blue
* Mean expression of Lao1  `r {rd1 %>% dplyr::filter(genes == "Lao1") %>% dplyr::select(baseMean) %>% pull()}` counts shown in green

Note: To paraphrase what Diana has told me "I [Diana] have validated
[Eif5a](https://www.ncbi.nlm.nih.gov/gene/1984) (mean count =
`r {rd1 %>% dplyr::filter(genes == "Eif5a") %>% dplyr::select(baseMean) %>% pull()}`),
as well as [Lao1](https://www.ncbi.nlm.nih.gov/gene?Db=gene&Cmd=DetailsSearch&Term=100470)
(mean count =
`r {rd1 %>% dplyr::filter(genes == "Lao1") %>% dplyr::select(baseMean) %>% pull()}`),
which as the validated gene with the lowest average counts across all samples."

If we have validated the presence of the protein gene product of
[Lao1](https://www.ncbi.nlm.nih.gov/gene?Db=gene&Cmd=DetailsSearch&Term=100470),
we can *potentially* credibly infer other genes with similar average transcript
count values are also valid.

```{r total_count, warning=FALSE, message=FALSE}
norm_gene_stats %>%
  tibble::rowid_to_column(var = "row_id") %>%
  ggplot(aes(x = row_id, y = log2(total_mean_counts))) +
  geom_point(size = 0.25, alpha = 0.5) +
  geom_hline(yintercept = rd1 %>%
               dplyr::filter(genes == "Eif5a") %>%
               dplyr::select(baseMean) %>% pull() %>% log2(),
             color = "blue", linetype = "dashed") +
  geom_hline(yintercept = rd1 %>%
               dplyr::filter(genes == "Lao1") %>%
               dplyr::select(baseMean) %>% pull() %>% log2(),
             color = "green", linetype = "dashed") +
  geom_hline(yintercept = mean(norm_gene_stats$total_mean_counts) %>% log2(),
             color = "red", linetype = "dashed") +
  # ylim(0, 50) + ## only show mean counts between 0 and 50
  xlab("gene ranking by total mean counts")
```

*How many genes can report with average counts above these thresholds?*

Genes with a mean count *greater than* the total mean of all genes in the count
matrix of 16 samples:

```{r}
norm_gene_stats  %>%
  dplyr::filter(total_mean_counts > mean(norm_gene_stats$total_mean_counts)) %>%
  nrow()
```

Genes with a mean count *greater than* the average mean count of `Eif5a`:

```{r}
norm_gene_stats  %>%
  dplyr::filter(total_mean_counts > (rd1 %>%
                  dplyr::filter(genes == "Eif5a") %>%
                  dplyr::select(baseMean) %>% pull())) %>%
  nrow()
```

Genes with a mean count *greater than* the average mean count of `Lao1`:

```{r}
norm_gene_stats  %>%
  dplyr::filter(total_mean_counts > (rd1 %>%
                  dplyr::filter(genes == "Lao1") %>%
                  dplyr::select(baseMean) %>% pull())) %>%
  nrow()
```

### Visualize missingness

Here, we treat the 0 counts as `NA` values and visualize them in a missingness
plot. We can observe that there are counts for ~98% of genes within all samples.

```{r}
norm_cts_na <- norm_cts
norm_cts_na[norm_cts_na == 0] <- NA
norm_cts_na %>%
  dplyr::select(-non_zero_vals) %>%
  naniar::vis_miss() +
  theme(axis.text.x = element_text(angle = 90))
```

### Ranking genes by count in control samples

```{r}
rd3 %>%
  # dplyr::filter(cooks_stat < 4/nrow(meta)) %>%
  dplyr::select(genes, meta %>%
                        dplyr::filter(class == "CTRL") %>%
                        dplyr::select(sample) %>%
                        dplyr::pull()) %>%
  tibble::column_to_rownames(var = "genes") %>%
  dplyr::mutate(mean_norm_counts = rowMeans(.)) %>%
  dplyr::arrange(desc(mean_norm_counts)) %>%
  tibble::rownames_to_column(var = "genes") %>%
  # dplyr::filter(mean_norm_counts > 5) %>%
  dplyr::select(genes, mean_norm_counts, everything()) %>%
  as.data.frame() -> control_count_mat
# writexl::write_xlsx(x = control_count_mat,
#                     path = paste0("./data/control_counts_ranked_no_cooks_",
#                                   Sys.Date(), ".xlsx"))
writexl::write_xlsx(x = control_count_mat,
                    path = paste0("./data/control_counts_final_", Sys.Date(),
                                  ".xlsx"))
```


Alejandro's suggestion for a "reliably detected" gene list consists of all genes
were there is a non-zero gene count measurement:

* across all samples (more conservative)
* across all control samples (less conservative)

The number of samples with non-zero values across all samples

```{r}
norm_cts %>%
  dplyr::filter(non_zero_vals == 16) -> norm_cts_non_0
nrow(norm_cts_non_0)
```

The number of samples with non-zero values across `control` all samples

```{r}
norm_cts %>%
  dplyr::select(meta %>%
                  dplyr::filter(class == "CTRL") %>%
                  dplyr::select(sample) %>%
                  dplyr::pull()) -> norm_cts_control
norm_cts_control$non_zero_vals <- apply(norm_cts_control == 0, 1, function(x) sum(x == 0))
norm_cts_control %>%
  dplyr::filter(non_zero_vals == 8) -> norm_cts_control_non_0
nrow(norm_cts_control_non_0)
```

## Save Results

The results of this analysis are saved as a Excel document with the following
sheets:

* Sheet 1 = Table of normalized counts and stats for all 16 samples
* Sheet 2 = All DEGs for `CTRL_ChATpos` vs `CTRL_ChATneg`
* Sheet 3 = Only significant DEGs for `CTRL_ChATpos` vs `CTRL_ChATneg`
* Sheet 4 = All DEGs for `CTRL_ChATpos` vs `FUS_ChATpos`
* Sheet 5 = Only significant DEGs for `CTRL_ChATpos` vs `FUS_ChATpos`

```{r save_data, warning=FALSE, message=FALSE}
l0 <- list(norm_gene_stats, rd1, sig1, rd2, sig2)
names(l0) <- c("Normalized genes and stats",
               "DEG CTRL_ChATpos v CTRL_ChATneg",
               "Sig CTRL_ChATpos v CTRL_ChATneg",
               "DEG CTRL_ChATpos v FUS_ChATpos",
               "Sig CTRL_ChATpos v FUS_ChATpos")
writexl::write_xlsx(x = l0, path = paste0("./data/NS_DEG_lists_final.xlsx"))
```

### Session Info

```{r}
sessionInfo()
```
